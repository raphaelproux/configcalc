{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Configcalc","text":"<p>Configcalc is a library to handle TOML configuration files with formulas. Formulas can make simple operations between variables contained in other parts of the configuration or given by the user at runtime. </p>"},{"location":"#usage","title":"Usage","text":"<p>Configcalc uses a TOML file. For example:</p> <pre><code>title = \"TOML Example\"\n\n[owner]\n\n[owner.info]\nname = \"Tom Preston-Werner\"\ndob = 1979-05-27T07:32:00-08:00\nnb_of_days_per_month = 30\nnb_of_months = 3\nnb_of_days = \"=nb_of_months * nb_of_days_per_month\"\ncalculated_value = \"= nb_of_days^3 * database.nb_of_ports + 2 / database.data[1][0]^2 * 2.32e-3 * _input_parts - cos(2*nb_of_days)\"\n</code></pre> <p>Some strings are actually a formula which begins with \"=\". This formula can refer to its context (here, for example, <code>nb_of_months</code>). The content of the TOML file can be read and the formulas calculated automatically.</p> <pre><code>import configcalc as cc\nconfig1 = cc.read_config_file(Path(r\"path/to/config_file1.toml\"))\nconfig2 = cc.read_config_file(Path(r\"path/to/config_file2.toml\"))\nmerged_config = cc.merge_configs(config1, config2)\ncalculated_config = cc.perform_calculations(\n        config=config,\n    )\n</code></pre>"},{"location":"config_reading/","title":"Config reading","text":""},{"location":"config_reading/#configcalc.read_cfg_file.read_config_file","title":"<code>read_config_file(path, parse_float=float)</code>","text":"<p>use parse_float argument to select whether you want numbers to be recognized as float or Decimal (typically)</p> Source code in <code>configcalc/read_cfg_file.py</code> <pre><code>def read_config_file(path: Path, parse_float: type[float] | Callable[[str], Decimal] = float) -&gt; dict[str, Any]:\n    \"\"\"use parse_float argument to select whether you want numbers to be recognized\n    as float or Decimal (typically)\"\"\"\n    content = tomllib.load(path.open(\"rb\"), parse_float=parse_float)\n    return content\n</code></pre>"},{"location":"parsers/","title":"Parsers","text":""},{"location":"parsers/#configcalc.parsers.build_operand_parser","title":"<code>build_operand_parser(number_parser)</code>","text":"<p>Builds the operand parser by removing the = sign at the beginning of the formula</p> <p>Parameters:</p> Name Type Description Default <code>number_parser</code> <code>Callable[[], ParserElement]</code> <p>number parser like decimal_parser or regular_number_parser</p> required <p>Returns:</p> Type Description <code>ParserElement</code> <p>pp.ParserElement: full formula parser for pyparsing</p> Source code in <code>configcalc/parsers.py</code> <pre><code>def build_operand_parser(\n    number_parser: Callable[[], pp.ParserElement],\n) -&gt; pp.ParserElement:\n    \"\"\"Builds the operand parser by removing the = sign at the beginning of the formula\n\n    Args:\n        number_parser (Callable[[], pp.ParserElement]): number parser like decimal_parser or regular_number_parser\n\n    Returns:\n        pp.ParserElement: full formula parser for pyparsing\n    \"\"\"\n    operator_operand = operator_operand_expr(number_parser)\n    return pp.Suppress(\"=\") + operator_operand\n</code></pre>"},{"location":"parsers/#configcalc.parsers.decimal_parser","title":"<code>decimal_parser()</code>","text":"<p>Parse numbers as Decimal</p> <p>Returns:</p> Type Description <code>ParserElement</code> <p>pp.ParserElement: Decimal ParserElement for pyparsing</p> Source code in <code>configcalc/parsers.py</code> <pre><code>def decimal_parser() -&gt; pp.ParserElement:\n    \"\"\"Parse numbers as Decimal\n\n    Returns:\n        pp.ParserElement: Decimal ParserElement for pyparsing\n    \"\"\"\n\n    def convert_to_decimal(token: pp.ParseResults) -&gt; Decimal:\n        return Decimal(str(token[0]))\n\n    int_part = pp.Opt(pp.one_of(\"- +\")) + pp.Word(pp.nums)\n    mantissa = int_part + pp.Opt(\".\" + pp.Opt(pp.Word(pp.nums)))\n    exponent_part = pp.Opt(\n        pp.one_of(\"e E\") + pp.Opt(pp.one_of(\"- +\")) + pp.Word(pp.nums)\n    )\n    number = pp.Combine(mantissa + exponent_part)\n    number.set_parse_action(convert_to_decimal)\n    return number\n</code></pre>"},{"location":"parsers/#configcalc.parsers.operator_operand_expr","title":"<code>operator_operand_expr(number_parser)</code>","text":"<p>Parse an operator operand with priority. In order (most priority to least) the minus sign (-), exponent (^), multiply/divide (* /) and add/substract (+ -)</p> <p>Parameters:</p> Name Type Description Default <code>number_parser</code> <code>Callable[[], ParserElement]</code> <p>number parser like decimal_parser or regular_number_parser</p> required <p>Returns:</p> Type Description <code>ParserElement</code> <p>pp.ParserElement: operand parser for pyparsing</p> Source code in <code>configcalc/parsers.py</code> <pre><code>def operator_operand_expr(\n    number_parser: Callable[[], pp.ParserElement],\n) -&gt; pp.ParserElement:\n    \"\"\"Parse an operator operand with priority. In order (most priority to least) the minus sign (-), exponent (^), multiply/divide (* /) and add/substract (+ -)\n\n    Args:\n        number_parser (Callable[[], pp.ParserElement]): number parser like decimal_parser or regular_number_parser\n\n    Returns:\n        pp.ParserElement: operand parser for pyparsing\n    \"\"\"\n    operator_operand = pp.Forward()\n    number = number_parser()\n    var_name = var_name_parser()\n    function_struct = (\n        pp.common.identifier + pp.Suppress(\"(\") + operator_operand + pp.Suppress(\")\")\n    )\n\n    operand = function_struct | number | var_name\n    operator_operand &lt;&lt;= pp.infix_notation(\n        operand,\n        [\n            (\"-\", 1, pp.OpAssoc.RIGHT),\n            (\"^\", 2, pp.OpAssoc.LEFT),\n            (pp.one_of(\"* /\"), 2, pp.OpAssoc.LEFT),\n            (pp.one_of(\"+ -\"), 2, pp.OpAssoc.LEFT),\n        ],\n    )\n    return operator_operand\n</code></pre>"},{"location":"parsers/#configcalc.parsers.regular_number_parser","title":"<code>regular_number_parser()</code>","text":"<p>Parse numbers as default from pyparsing</p> <p>Returns:</p> Type Description <code>ParserElement</code> <p>pp.ParserElement: Common number ParserElement for pyparsing</p> Source code in <code>configcalc/parsers.py</code> <pre><code>def regular_number_parser() -&gt; pp.ParserElement:\n    \"\"\"Parse numbers as default from pyparsing\n\n    Returns:\n        pp.ParserElement: Common number ParserElement for pyparsing\n    \"\"\"\n    return pp.common.number\n</code></pre>"},{"location":"parsers/#configcalc.parsers.var_name_parser","title":"<code>var_name_parser()</code>","text":"<p>Parse a variable number composed of a base name and a tree like structure using dots (.) or a list like structure using square brackets ([]), or a combination of both.</p> <p>Returns:</p> Type Description <code>ParserElement</code> <p>pp.ParserElement: var name ParserElement for pyparsing</p> Source code in <code>configcalc/parsers.py</code> <pre><code>def var_name_parser() -&gt; pp.ParserElement:\n    \"\"\"Parse a variable number composed of a base name and a tree like structure\n    using dots (.) or a list like structure using square brackets ([]), or a combination of both.\n\n    Returns:\n        pp.ParserElement: var name ParserElement for pyparsing\n    \"\"\"\n    dict_like_key = pp.Suppress(\".\") + pp.common.identifier\n    list_like_index = pp.Suppress(\"[\") + pp.common.integer + pp.Suppress(\"]\")\n    subvar_element = dict_like_key ^ list_like_index\n    return pp.Group(pp.common.identifier + subvar_element[...], aslist=True)\n</code></pre>"},{"location":"perform_calculations/","title":"Perform calculations","text":""},{"location":"perform_calculations/#configcalc.perform_calcs.find_formulas","title":"<code>find_formulas(dictionary)</code>","text":"<p>finds all formulas in a nested dictionary</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict[str, Any]</code> <p>config dictionary</p> required <p>Returns:</p> Type Description <code>dict[tuple[str, ...], str]</code> <p>dict[tuple[str, ...], str]: dictionary of formulas. Keys are a tuple of keys to access the value in the tree</p> Source code in <code>configcalc/perform_calcs.py</code> <pre><code>def find_formulas(dictionary: dict[str, Any]) -&gt; dict[tuple[str, ...], str]:\n    \"\"\"finds all formulas in a nested dictionary\n\n    Args:\n        dictionary (dict[str, Any]): config dictionary\n\n    Returns:\n        dict[tuple[str, ...], str]: dictionary of formulas. Keys are a tuple of keys to access the value in the tree\n    \"\"\"\n    formulas = {}\n    for key, value in dictionary.items():\n        if isinstance(value, str) and value.startswith(\"=\"):\n            formulas[(key,)] = value\n        elif isinstance(value, dict):\n            nested_dict = find_formulas(value)\n            for nested_key, nested_value in nested_dict.items():\n                formulas[(key, *nested_key)] = nested_value\n    return formulas\n</code></pre>"},{"location":"perform_calculations/#configcalc.perform_calcs.find_var_ref_indices","title":"<code>find_var_ref_indices(parsed_lists)</code>","text":"<p>find positions of var values in parsed formulas from the parser as a list of indices of all variables</p> <p>Parameters:</p> Name Type Description Default <code>parsed_lists</code> <code>list[Any]</code> <p>parsed formula</p> required <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>list[list[int]]: description</p> Source code in <code>configcalc/perform_calcs.py</code> <pre><code>def find_var_ref_indices(parsed_lists: list[Any]) -&gt; list[list[int]]:\n    \"\"\"find positions of var values in parsed formulas from the parser as a list of indices of all variables\n\n    Args:\n        parsed_lists (list[Any]): parsed formula\n\n    Returns:\n        list[list[int]]: _description_\n    \"\"\"\n    \"\"\"find positions as a list of indices of all variables in parsed lists from the parser\"\"\"\n    base_elements_indices = []\n    for i, element in enumerate(parsed_lists):\n        # we have a var name\n        if (\n            isinstance(element, list)\n            and isinstance(element[0], str)\n            and element[0] not in MATH_FUNCTIONS\n        ):\n            # base_element = element[0]\n            # print(element)\n            base_elements_indices.append([i])\n        elif isinstance(element, list):\n            base_elements_indices.extend(\n                [[i, *inner_indices] for inner_indices in find_var_ref_indices(element)]\n            )\n    return base_elements_indices\n</code></pre>"},{"location":"perform_calculations/#configcalc.perform_calcs.get_value_in_data","title":"<code>get_value_in_data(data, list_identifier)</code>","text":"<p>get the value of a variable from its list identifier</p> Source code in <code>configcalc/perform_calcs.py</code> <pre><code>def get_value_in_data(data: dict[str, Any], list_identifier: list[str | int]) -&gt; Any:\n    \"\"\"get the value of a variable from its list identifier\"\"\"\n    item = data\n    for i_or_key in list_identifier:\n        item = item[i_or_key]\n    return item\n</code></pre>"},{"location":"perform_calculations/#configcalc.perform_calcs.perform_calculations","title":"<code>perform_calculations(config, context_variables=None, number_type=NumberType.FLOAT)</code>","text":"<p>resolves all possible calculations in config dictionary</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>config dictionary as given by read_config_file</p> required <code>context_variables</code> <code>dict[str, Any] | None</code> <p>additional variable values to use for calculations. Defaults to None.</p> <code>None</code> <code>number_type</code> <code>NumberType</code> <p>number type to use (e.g. NumberType.DECIMAL). Defaults to FLOAT.</p> <code>FLOAT</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: config dictionary with all calculations resolved</p> Source code in <code>configcalc/perform_calcs.py</code> <pre><code>def perform_calculations(\n    config: dict[str, Any],\n    context_variables: dict[str, Any] | None = None,\n    number_type: NumberType = NumberType.FLOAT,\n) -&gt; dict[str, Any]:\n    \"\"\"resolves all possible calculations in config dictionary\n\n    Args:\n        config (dict[str, Any]): config dictionary as given by read_config_file\n        context_variables (dict[str, Any] | None, optional): additional variable values to use for calculations. Defaults to None.\n        number_type (NumberType, optional): number type to use (e.g. NumberType.DECIMAL). Defaults to FLOAT.\n\n    Returns:\n        dict[str, Any]: config dictionary with all calculations resolved\n    \"\"\"\n\n    if context_variables is None:\n        context_variables = {}\n    number_parser_element, number_parser_function = number_formatters[number_type]\n    operand_parser = build_operand_parser(number_parser=number_parser_element)\n    parse_any_value = functools.partial(_parse_any_value, operand_parser=operand_parser)\n    formulas = find_formulas(config)\n    for formula_position, formula in list(formulas.items()):\n        parsed_formula = operand_parser.parse_string(formula).asList()\n        parsed_formula_w_value = replace_vars_by_values(\n            parsed_formula=parsed_formula,\n            data=config,\n            formula_position=list(formula_position),\n            context_variables=context_variables,\n            parse_any_value=parse_any_value,\n        )\n        calculated_value = calculate_formula_w_value(\n            parsed_formula_w_value, parse_float=number_parser_function\n        )\n        set_deep(\n            nested_list=config, indices=list(formula_position), value=calculated_value\n        )\n    return config\n</code></pre>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#configcalc.utils.NumberType","title":"<code>NumberType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration FLOAT or DECIMAL to specify number type.</p> Source code in <code>configcalc/utils.py</code> <pre><code>class NumberType(Enum):\n    \"\"\"Enumeration FLOAT or DECIMAL to specify number type.\"\"\"\n\n    FLOAT = auto()\n    DECIMAL = auto()\n</code></pre>"},{"location":"utils/#configcalc.utils.get_deep","title":"<code>get_deep(nested_list, indices)</code>","text":"<p>Gets element in nested list</p> <p>Parameters:</p> Name Type Description Default <code>nested_list</code> <code>list[Any]</code> <p>list with possible sublists</p> required <code>indices</code> <code>list[int]</code> <p>list of indices on each list to locate the element, from top to bottom</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>element value</p> Source code in <code>configcalc/utils.py</code> <pre><code>def get_deep(nested_list: list[Any], indices: list[int]) -&gt; Any:\n    \"\"\"Gets element in nested list\n\n    Args:\n        nested_list (list[Any]): list with possible sublists\n        indices (list[int]): list of indices on each list to locate the element, from top to bottom\n\n    Returns:\n        Any: element value\n    \"\"\"\n    # see https://stackoverflow.com/a/44579249/10926757\n    if (len(indices) &gt; 1) and (isinstance(nested_list[indices[0]], (list, dict))):\n        return get_deep(nested_list[indices[0]], indices[1:])\n    else:\n        return nested_list[indices[0]]\n</code></pre>"},{"location":"utils/#configcalc.utils.set_deep","title":"<code>set_deep(nested_list, indices, value)</code>","text":"<p>Sets an element value deep in a nested list</p> <p>Parameters:</p> Name Type Description Default <code>nested_list</code> <code>list[Any]</code> <p>nested list</p> required <code>indices</code> <code>list[int]</code> <p>list of indices to the element</p> required <code>value</code> <code>Any</code> <p>new value of element</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>list[Any]: nested list with updated value of element</p> Source code in <code>configcalc/utils.py</code> <pre><code>def set_deep(nested_list: list[Any], indices: list[int], value: Any) -&gt; list[Any]:\n    \"\"\"Sets an element value deep in a nested list\n\n    Args:\n        nested_list (list[Any]): nested list\n        indices (list[int]): list of indices to the element\n        value (Any): new value of element\n\n    Returns:\n        list[Any]: nested list with updated value of element\n    \"\"\"\n    if (len(indices) &gt; 1) and isinstance(nested_list[indices[0]], (list, dict)):\n        set_deep(nested_list[indices[0]], indices[1:], value)\n    else:\n        nested_list[indices[0]] = value\n    return nested_list\n</code></pre>"}]}